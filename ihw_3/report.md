# ИДЗ 2 ОС

## Оробцов Вячеслав Алексеевич БПИ214

### Условие задачи (Вариант 36)

Задача о сельской библиотеке.

В библиотеке имеется N книг, каждая из книг в одном экземпляре. M читателей регулярно заглядывают в библиотеку, каждый из них выбирает для чтения одну книгу и читает ее некоторое количество дней. Если желаемой книги нет, то читатель дожидается от библиотекаря информации об ее появлении и приходит в библиотеку, чтобы специально забрать ее. Возможна ситуация, когда несколько читателей конкурируют из-за этой популярной книги. Создать приложение, моделирующее заданный процесс. Библиотекарь и читатели должны быть представлены в виде отдельных процессов.

### Общая схема решаемой задачи

В программе "день" из условия соответствует двум секундам в реальности. Читатели будут "читать" книгу случайное число дней (от 1 до 3 дней), выбирать книгу также случайно.

Числа N и M вводятся при запуске программы в виде аргументов командной строки следующим образом: `./prog N M`, где N, M - некоторые числа.

Далее программа выполняет следующее:

Создает массив из N чисел `library` и инициализирует их единицами, что будет представлять собой библиотеку (количества каждой из N книг). Доступ к этому массиву имеют все процессы, причем только библиотекарь может менять его значения, остальные читатели могут только читать значения из этого массива.

Создает две целочисленные переменные `window` и `answer`. Обе являются разделяемыми. Первая переменная служит для взаимодействия некоторого читателя и библиотекаря, доступ к ней будет синхронизироваться, читатели могут только писать в нее, а библиотекарь только читать.

Чтобы прочесть книгу или отдать её, читатель должен будет получить доступ к этой переменной и записать туда число - номер книги, которую хочет прочесть (или номер книги со знаком минус, если хочет отдать. Для такого взаимодействия будем считать, что читатели нумеруют книги с единицы).

Библиотекарь, получив значение из `window`, обрабатывает запрос соответствующим образом: если это отрицательное число, то обновляет массив `library` и ждет новый запрос. Если это положительное число, то библиотекарь должен посмотреть на наличие данной книги в массиве, если её нет, то в переменную `answer` записать число -1, если есть, то обновить массив `library` и записать в переменную `answer` число 1, после чего продолжить ожидание новых запросов. Читатель, получив в качестве ответа единицу, будет читать книгу. Получив в качестве ответа -1, он будет смотреть на значение интересующей книги в массиве `library`, и когда оно станет равным единице, пойдет к библиотекарю за этой же книгой.

Порядок чтения/записи значений и доступа к переменным будет синхронизирован с помощью семафоров, выполняющих роль мьютексов.

Чтобы процессы не генерировали одинаковый номер книги вначале, каждый из них будет спать столько секунд, сколько указано единиц в его значении id. То есть, каждый читатель будет подключаться к работе каждую секунду, инициализируя srand разным значением.

Последующие действия зависят от оценки, которой соответствует программа.

### Общая схема решаемой задачи (4 балла)

Множество процессов взаимодействуют с использованием именованных POSIX семафоров. Обмен данными ведется через разделяемую память в стандарте POSIX.

После вышеописанных процедур, главный процесс создает M дочерних процессов. Каждый дочерний процесс запускает функцию `reader_proc()`, которой в качестве аргумента передается максимальный размер библиотеки N и уникальный id процесса (задается главным процессом значением от 0 до M-1).

После запуска дочерних процессов, главный процесс вызывает функцию `librarian_proc()`, которой в качестве аргумента передается число N.

Дочерним процессам нет надобности открывать семафоры заново, поэтому достаточно один раз их открыть и закрыть в главном процессе.

Программа завершается с помощью Ctrl+C. После получения сигнала, главный процесс закрывает разделяемую память, семафоры, и удаляет их.

Пример вывода нескольких строк рабочей программы:

```
$ gcc main.c common.c -o p
$ ./p 2 4
Reader_0: Иду за книгой 1
Reader_1: Иду за книгой 1
Librarian: книга 1 отдана.
Reader_2: Иду за книгой 1
Reader_0: Книга 1 есть. Читаю 2 дн.
Reader_3: Иду за книгой 1
Librarian: книги 1 нет.
Reader_1: Книги 1 нет. Жду.
Librarian: книги 1 нет.
Reader_2: Книги 1 нет. Жду.
Librarian: книги 1 нет.
Reader_3: Книги 1 нет. Жду.
Reader_0: Возвращаю книгу 1
Librarian: книга 1 получена.
Reader_2: Иду за книгой 1
Reader_3: Иду за книгой 1
Reader_1: Иду за книгой 1
Reader_0: Иду за книгой 1
Librarian: книга 1 отдана.
Reader_2: Книга 1 есть. Читаю 2 дн.
Librarian: книги 1 нет.
Reader_3: Книги 1 нет. Жду.
Librarian: книги 1 нет.
Reader_1: Книги 1 нет. Жду.
Librarian: книги 1 нет.
Reader_0: Книги 1 нет. Жду.
Reader_2: Возвращаю книгу 1
Librarian: книга 1 получена.
^C
Программа останавливается...
Программа завершена.
```

### Общая схема решаемой задачи (5 баллов)

Множество процессов взаимодействуют с использованием неименованных POSIX семафоров расположенных в разделяемой памяти. Обмен данными также ведется через разделяемую память в стандарте POSIX.

В остальном, программа копирует поведение программы на 4 балла.

### Общая схема решаемой задачи (6 баллов)

Множество процессов взаимодействуют с использованием семафоров в стандарте UNIX SYSTEM V. Обмен данными ведется через разделяемую память в стандарте UNIX SYSTEM V.

Целочисленные переменные были склеены в 1 массив `library_window_answer` для удобства, где нулевой элемент - window, следующие N чисел - library, а N+1-е число - answer. Три семафора также были склеены в массив семафоров в следующем порядке: первый семафор - window для reader'ов, второй - window для librarian, третий - answer.

В остальном, программа копирует поведение программы на 4 балла.
